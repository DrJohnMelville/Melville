using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Melville.Linq
{
    public static class GraphAlgorithms
    {
        /// <summary>
        /// Perform a topologic sort such that all elements that are referenced appear before their reference.
        /// </summary>
        /// <typeparam name="T">The base type of the enumeration</typeparam>
        /// <param name="source">The items to sort</param>
        /// <param name="children">a function that, given an element returns the target of the element.</param>
        /// <returns></returns>
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures",
            Justification = "Nested type generated by lambda exp.")]
        public static IEnumerable<T> TopologicSort<T>(this IEnumerable<T> source, Func<T, IEnumerable<T>> children)
        {
            return InnerTopologicSort(source, children);
        }

        private static IEnumerable<T> InnerTopologicSort<T>(IEnumerable<T> source, Func<T, IEnumerable<T>> children)
        {
            var nodesAlreadyReturned = new HashSet<T>();
            var stack = new Stack<(T, IEnumerator<T>)>();
            foreach (T node in source)
            {
                if (nodesAlreadyReturned.Contains(node))
                    continue;
                stack.Push(MakeStackItem(node, children));
                while (stack.Any())
                {
                    var top = stack.Peek();
                    if (!top.Item2.MoveNext())
                    {
                        // end of an iteration
                        top.Item2.Dispose();
                        nodesAlreadyReturned.Add(top.Item1);
                        yield return top.Item1;
                        stack.Pop();
                    }
                    else
                    {
                        T newItem = top.Item2.Current;
                        if (stack.Any(p => object.Equals(p.Item1, newItem)))
                            throw new InvalidOperationException("Cannot do a topologic sort with a cycle");
                        if (!nodesAlreadyReturned.Contains(newItem))
                        {
                            stack.Push(MakeStackItem(newItem, children));
                        }
                    }
                }
            }
        }

        private static (T, IEnumerator<T>) MakeStackItem<T>(T node, Func<T, IEnumerable<T>> children) =>
            (node, children(node).GetEnumerator());
    }
}