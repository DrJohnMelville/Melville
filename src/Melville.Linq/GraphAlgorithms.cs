using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Melville.Linq
{
  public static class GraphAlgorithms
  {
    /// <summary>
    /// Perform a topologic sort such that all elements that are referenced appear before their reference.
    /// </summary>
    /// <typeparam name="T">The base type of the enumeration</typeparam>
    /// <param name="source">The items to sort</param>
    /// <param name="children">a function that, given an element returns the target of the element.</param>
    /// <returns></returns>
    [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures", Justification = "Nested type generated by lambda exp.")]
    public static IEnumerable<T> TopologicSort<T>(this IEnumerable<T> source, Func<T, IEnumerable<T>> children)
    {
      return InnerTopologicSort(source, children);
    }
    private static IEnumerable<T> InnerTopologicSort<T>(IEnumerable<T> source, Func<T, IEnumerable<T>> children)
    {
      var nodesAlreadyReturned = new HashSet<T>();
      var stack = new Stack<(T, IEnumerator<T>)>();
      foreach (T node in source)
      {
        if (nodesAlreadyReturned.Contains(node))
          continue;
        stack.Push(MakeStackItem(node, children));
        while (stack.Any())
        {
          var top = stack.Peek();
          if (!top.Item2.MoveNext())
          { // end of an iteration
            top.Item2.Dispose();
            nodesAlreadyReturned.Add(top.Item1);
            yield return top.Item1;
            stack.Pop();
          }
          else
          {
            T newItem = top.Item2.Current;
            if (stack.Any(p => object.Equals(p.Item1, newItem)))
              throw new InvalidOperationException("Cannot do a topologic sort with a cycle");
            if (!nodesAlreadyReturned.Contains(newItem))
            {
              stack.Push(MakeStackItem(newItem, children));
            }
          }
        }
      }
    }
    /// <summary>
    /// Makes the stack members for the topological sort method
    /// </summary>
    /// <typeparam name="T">Type of the nodes to sort</typeparam>
    /// <param name="node">The node to create a stack element for.</param>
    /// <param name="children">The functions that will compute the dependant nodes of a given node.</param>
    /// <returns>The stack element for the given node.</returns>
    private static (T, IEnumerator<T>) MakeStackItem<T>(T node, Func<T, IEnumerable<T>> children) => 
      (node, children(node).GetEnumerator());

    /// <summary>
    /// From kevin moore's blog.  Get an entire tree of nodes using the given function to find children.
    /// This function implements a preorder traversal.
    /// </summary>
    /// <typeparam name="TSource">The type of the node being found.</typeparam>
    /// <param name="source">The root of the tree.</param>
    /// <param name="recursiveSelector">The function the maps any node to the enumeration of its children.</param>
    /// <returns>All of the children and subchildren of this node in pre-order</returns>
    [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures", Justification = "Nested type generated by lambda exp.")]
    public static IEnumerable<TSource> SelectRecursive<TSource>(
      this IEnumerable<TSource> source,
      Func<TSource, IEnumerable<TSource>> recursiveSelector) 
    {
      Stack<IEnumerator<TSource>> stack = new();
      PushEnumeratorIfNotNull(stack, source);

      try
      {
        while (stack.Count > 0)
        {
          var stackTop = stack.Peek();
          if (stackTop.MoveNext())
          {
            yield return stackTop.Current;
            PushEnumeratorIfNotNull(stack, recursiveSelector(stackTop.Current));
          }
          else
          {
            stack.Pop().Dispose();
          }
        }
      }
      finally
      {
        while (stack.Count > 0)
        {
          IEnumerator<TSource> topItem = stack.Pop();
          topItem.Dispose();
        }
      }
    }

    private static void PushEnumeratorIfNotNull<TSource>(Stack<IEnumerator<TSource>> stack, IEnumerable<TSource> newSequence)
    {
      if (newSequence != null)
        stack.Push(newSequence.GetEnumerator());
    }
  }
}